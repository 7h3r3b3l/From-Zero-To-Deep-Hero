"""
               Made By
               7h3r3b3l
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⡶⢶⣆⠀⠶⣇⢀⣾⡇⢠⣿⢂⣰⡾⢀⣶⡶⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣤⣾⣧⣂⠻⣧⡨⠻⣷⠀⣿⠮⢹⠇⢸⡿⣸⡿⠁⣿⡟⣤⡿⠁⣨⠿⣶⣄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣴⣿⣿⠋⠻⣷⣤⣰⠝⡐⢝⠀⡘⠀⡈⠀⠀⠃⠘⢱⢀⢿⠠⠿⣱⠟⢩⣤⣾⣿⣷⣄⠀⠀⠀⠀
⠀⠀⢀⣾⣿⣿⣏⡉⣣⣊⠙⢓⠃⡘⠈⠀⢁⠀⠆⢀⠀⠡⠂⠄⠰⠈⠀⠙⠡⣃⣉⢙⡿⠿⣿⣿⣧⠀⠀⠀
⠀⠀⣾⣿⣿⠄⠬⠭⠭⣽⠚⠀⠃⠌⠀⡄⢸⠀⡀⠀⠀⠇⠈⠠⠁⠤⠐⠈⠝⢉⡭⠗⢲⣤⣿⣿⣿⣧⠀⠀
⠀⢠⣿⣿⣿⣶⣿⠂⠶⠀⢄⢣⠁⣄⠰⠄⢈⠂⡱⢀⠀⠀⠇⠀⠀⠀⠤⠴⠐⠂⢐⡥⢭⣥⣨⣿⣿⣿⠀⠀
⠀⢸⣿⣿⢉⣙⣛⣻⠛⣛⠀⠊⠑⠄⠈⠀⠐⠀⠀⠘⠀⠀⠠⠂⠒⡉⠀⡀⠎⠤⠀⣤⣄⣽⣿⣿⣿⣿⠀⠀
⠀⢸⣿⣿⣿⠿⠿⠀⣈⣋⠱⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠤⠁⠬⠂⣌⣛⠛⣿⣿⣿⣿⠀⠀
⠀⢸⣿⣿⣿⣶⣿⠟⢟⣭⣴⠶⣁⢫⠀⢀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠈⠀⣿⣿⣷⣤⣽⣿⣿⣿⣿⣿⠀⠀
⠀⢸⣿⣿⣿⣿⣿⣷⣿⣿⣇⣼⣿⡘⢰⣛⡆⠀⠐⠡⣞⡧⠀⠀⠀⣀⠘⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀
⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡠⠍⠀⡀⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠿⣿⣿⣿⣿⣿⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠹⣿⣿⣿⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⠀⠀⣿⣿⣿⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠀⠀⠀⠀⣿⣿⡏⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⢰⠀⠀⠀⠀⣿⣿⠁⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠀⢀⣀⠀⠀⠀⠂⠀⠀⠀⡿⠃⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀

Secction 3.2 - Object Oriented Design for implementation
d2l.ai
"""
from d2l import torch as d2l
from torch import nn
import numpy as np
import time
import torch

# Three classes: 1. Module, 2. Data Module, 3. Data validator

# Module - Contains models, losses and optimization methods
# DataModule - Contains data and validator
# Trainer - train the model with the data loader


## Define a wrapper that adds a function into a class

# Define the wrapper
def add_to_class(Class):
    """
    This is a method that led register a function as a
    function for a class outside of the class
    """
    def wrapper(obj):
        # Just add the attritute to the class
        setattr(Class, obj.__name__, obj)
    return wrapper

# Define the function

class Lol:
    def __init__(self, var):
        self.var = var

# Define a function outside of the class and add it using the wrapper

@add_to_class(Lol)
def printvar(self):
    print(f'var of {self.__ne__} is {self.var}')
    return self.var

obj = Lol(10)
obj.printvar()

## Define an utility that saves the arguments in a class' __init__


add_to_class(d2l.HyperParameters)  
def save_hyperparameters(self, ignore=[]):
    """Save function arguments into class attributes."""
    frame = inspect.currentframe().f_back
    _, _, _, local_vars = inspect.getargvalues(frame)
    self.hparams = {k:v for k, v in local_vars.items()
                    if k not in set(ignore+['self']) and not k.startswith('_')}
    for k, v in self.hparams.items():
        setattr(self, k, v)


#lol = HyperParameters()
#lol.save_hyperparameters()

## Into Neural Networks - Modules

class Module(nn.Module, d2l.HyperParameters):
    """Model's base class"""
    def __init__(self, prot_train_per_epoch=2, plot_valid_per_epoch=1):
        super().__init__()
        self.save_hyperparameters()
        self.board = ProgressBoard()

    def loss(self, y_har, y):
        raise NotImplemented

    def forward(self, X):
        assert hasattr(self, 'net'), "Neural network is already defined!"
        return self.net(X)

    def plot(self, key, value, train):
        """Plot a point in animation."""
        assert hasattr(self, 'trainer'), 'Trainer is not inited'
        self.board.xlabel = 'epoch'
        if train:
            x = self.trainer.train_batch_idx / \
                self.trainer.num_train_batches
            n = self.trainer.num_train_batches / \
                self.plot_train_per_epoch
        else:
            x = self.trainer.epoch + 1
            n = self.trainer.num_val_batches / \
                self.plot_valid_per_epoch
        self.board.draw(x, value.to(d2l.cpu()).detach().numpy(),
                        ('train_' if train else 'val_') + key,
                        every_n=int(n))


    def training_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('loss', l, train=True)
        return l

    def validation_step(self, batch):
        l = self.loss(self(*batch[:-1]), batch[-1])
        self.plot('loss', l, train=False)

    def configure_optimizers(self):
        raise NotImplementedError
